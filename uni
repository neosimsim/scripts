#!/usr/bin/env stack
-- stack --resolver lts-14.6 script --package protolude --package text --package containers --package either --package bytestring --package megaparsec --ghc-options -Wall --ghc-options -Werror
--
-- to test run:  echo "\lambda(x.x) \Rightarrow \lambda{}-calc" | ./tex2text # = Î»(x.x) â‡’ Î»-calc
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}

import           Control.Monad
import           Data.Either.Combinators
import qualified Data.Map                as M
import           Data.Text               hiding (map)
import           Data.Text.IO
import           Data.Text.Encoding
import           Protolude               hiding (concat, putStr, putStrLn)
import           Text.Megaparsec         as P
import           Text.Megaparsec.Char
import qualified Data.ByteString as B

mapping :: [(Text, Text)]
mapping
    -- Superscripts
 =
  [ ("^0", "â°")
  , ("^1", "Â¹")
  , ("^2", "Â²")
  , ("^3", "Â³")
  , ("^4", "â´")
  , ("^5", "âµ")
  , ("^6", "â¶")
  , ("^7", "â·")
  , ("^8", "â¸")
  , ("^9", "â¹")
  , ("^+", "âº")
  , ("^-", "â»")
  , ("^=", "â¼")
  , ("^(", "â½")
  , ("^)", "â¾")
  , ("^n", "â¿")
    -- Subscripts
  , ("_0", "â‚€")
  , ("_1", "â‚")
  , ("_2", "â‚‚")
  , ("_3", "â‚ƒ")
  , ("_4", "â‚„")
  , ("_5", "â‚…")
  , ("_6", "â‚†")
  , ("_7", "â‚‡")
  , ("_8", "â‚ˆ")
  , ("_9", "â‚‰")
  , ("_+", "â‚Š")
  , ("_-", "â‚‹")
  , ("_=", "â‚Œ")
  , ("_(", "â‚")
  , ("_)", "â‚")
    -- Arrows
  , ("->", "â†’")
  , ("<--", "â†")
  , ("<-->", "â†”")
  , ("=>", "â‡’")
  , ("<=", "â‡")
  , ("<=>", "â‡”")
    -- Symbols from mathematics and logic, LaTeX style
  , ("forall", "âˆ€")
  , ("exists", "âˆƒ")
  , ("in", "âˆˆ")
  , ("ni", "âˆ‹")
  , ("empty", "âˆ…")
  , ("prod", "âˆ")
  , ("sum", "âˆ‘")
  , ("le", "â‰¤")
  , ("ge", "â‰¥")
  , ("pm", "Â±")
  , ("subset", "âŠ‚")
  , ("subseteq", "âŠ†")
  , ("supset", "âŠƒ")
  , ("supseteq", "âŠ‡")
  , ("setminus", "âˆ–")
  , ("cap", "âˆ©")
  , ("cup", "âˆª")
  , ("int", "âˆ«")
  , ("therefore", "âˆ´")
  , ("qed", "âˆ")
  , ("1", "ğŸ™")
  , ("N", "â„•")
  , ("Z", "â„¤")
  , ("C", "â„‚")
  , ("Q", "â„š")
  , ("R", "â„")
  , ("E", "ğ”¼")
  , ("F", "ğ”½")
  , ("to", "â†’")
  , ("mapsto", "â†¦")
  , ("infty", "âˆ")
  , ("cong", "â‰…")
  , ("=", "â‰¡")
  , ("=:", "â‰•")
  , ("ne", "â‰ ")
  , ("approx", "â‰ˆ")
  , ("top", "âŠ¤")
  , ("bot", "âŠ¥")
  , ("perp", "âŠ¥")
  , ("not", "Ì·")
  , ("ldots", "â€¦")
  , ("cdots", "â‹¯")
  , ("cdot", "â‹…")
  , ("circ", "â—¦")
  , ("times", "Ã—")
  , ("oplus", "âŠ•")
  , ("langle", "âŸ¨")
  , ("<", "âŸ¨")
  , ("rangle", "âŸ©")
  , (">", "âŸ©")
  , ("=<>","â‰¡âŸ¨âŸ©")
  , ("::","âˆ·")
    -- Greek alphabetâ€¦
  , ("alpha", "Î±")
  , ("beta", "Î²")
  , ("gamma", "Î³")
  , ("delta", "Î´")
  , ("epsilon", "Îµ")
  , ("zeta", "Î¶")
  , ("eta", "Î·")
  , ("theta", "Î¸")
  , ("iota", "Î¹")
  , ("kappa", "Îº")
  , ("lambda", "Î»")
  , ("mu", "Î¼")
  , ("nu", "Î½")
  , ("xi", "Î¾")
  , ("omicron", "Î¿")
  , ("pi", "Ï€")
  , ("rho", "Ï")
  , ("stigma", "Ï‚")
  , ("sigma", "Ïƒ")
  , ("tau", "Ï„")
  , ("upsilon", "Ï…")
  , ("phi", "Ï•")
  , ("varphi", "Ï†")
  , ("chi", "Ï‡")
  , ("psi", "Ïˆ")
  , ("omega", "Ï‰")
  , ("Alpha", "Î‘")
  , ("Beta", "Î’")
  , ("Gamma", "Î“")
  , ("Delta", "Î”")
  , ("Epsilon", "Î•")
  , ("Zeta", "Î–")
  , ("Eta", "Î—")
  , ("Theta", "Î˜")
  , ("Iota", "Î™")
  , ("Kappa", "Îš")
  , ("Lambda", "Î›")
  , ("Mu", "Îœ")
  , ("Nu", "Î")
  , ("Xi", "Î")
  , ("Omicron", "ÎŸ")
  , ("Pi", "Î ")
  , ("Rho", "Î¡")
  , ("Sigma", "Î£")
  , ("Tau", "Î¤")
  , ("Upsilon", "Î¥")
  , ("Phi", "Î¦")
  , ("Chi", "Î§")
  , ("Psi", "Î¨")
  , ("Omega", "Î©")
  -- smiley
  , (":)", "â˜º")
  , ("XD", "ğŸ˜")
  , (";)", "ğŸ˜‰")
  -- misc
  , (",", "â€¯") -- Narrow No-Break Space
  , ("~", "Â ") -- No-Break Space
  ]

data Fragment
  = Plain Text
  | Escaped Text
  deriving (Show)

type Partition = [Fragment]

resolve :: [(Text, Text)] -> Fragment -> Text
resolve _ (Plain t) = t
resolve m (Escaped e) = fromMaybe ("\\" `append` e) (M.lookup e $ M.fromList m)

type Parser = Parsec Void Text

pPlain :: Parser Fragment
pPlain =
  Plain . pack <$> manyTill anySingle (lookAhead (void (char '\\')) <|> eof)

pEscaped :: Parser Fragment
pEscaped = do
  fragment <-
    Escaped . pack <$>
    (char '\\' >>
     P.manyTill
       anySingle
       (lookAhead (void (char '{')) <|> lookAhead (void (char '\\')) <|>
        lookAhead (void spaceChar) <|>
        eof))
  -- an optional {} allows an escaped term to be followed by plain text
  -- without any whitespace in between.
  _ <- P.observing $ string "{}"
  return fragment

pFragment :: Parser Fragment
pFragment = pEscaped <|> pPlain

pPartition :: Parser Partition
pPartition = do
  end <- atEnd
  if end
    then return []
    else (:) <$> pFragment <*> pPartition

parsePartition :: Text -> Either Text Partition
parsePartition = mapLeft (pack . errorBundlePretty) . P.parse pPartition ""

main :: IO ()
main = do
  stdIn <- getContents
  case parsePartition stdIn of
    Left e     -> putStrLn e
    Right part -> B.putStr . encodeUtf8 . concat $ map (resolve mapping) part
